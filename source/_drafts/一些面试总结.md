---
title: 一些面试总结
date: 2017-08-07 19:29:09
tags:
- 前端
catalogies:
- 面试
---

# 前言

最近参加了一些面试，暴露了自己很多的不足，真是“基础不牢，地动山摇······”，压力山大呀。

<!-- more -->
# 1.浏览器执行的单线程

JS是单线程的，浏览器本身不是单线程的而是多线程的，但浏览器执行JS时是单线程的，同一时刻只有一段代码在运行，所谓的异步其实时浏览器执行JS时的一种机制。

比如setTimeout函数，它将需要推迟执行的代码放入一个队列中去，当定时到达时并且浏览器JS执行器空闲时才会执行，所有的异步操作都是这种原理。

比如

```js
function a() {
    while (true){};
    console.log('a');
}

setTimeout(function(){
    console.log('b');
}, 0)

a();
console.log('get to it');

```

如上代码，a中死循环；后面的代码根本不会执行。

# 2.`__proto__`与`prototype`

1. 首先，这两个东西是一个引用，指向的是一个东西，即对象的原型。
2. `__proto__`是浏览器对原型的一个暴露API，`prototype`则是原生JS语法中的API。
3. 区别是什么呢，区别是`prototype`是函数对象中的一个属性，普通对象不含有，而`__proto__`则是所有对象都有的（浏览器环境与Node环境），本质上其实是`Object.getPrototypeOf(对象)`

# 3.new一个对象

在new一个对象时，发生以下事件：

- 创建一个空object
- 将空对象的原型指向构造函数
- 将this指针绑定到空对象上

# 4.delete操作

`delete`运算符能够删除一个对象的属性。但是如下代码是无法删除的, 因为对于函数来说，其参数并不属于函数的属性：

```js
(function(x) {
    delete x;
    console.log(x);
})(6)

// 6
```

# 5.一些面试题

```js
function Boy() {};

Boy.prototype.grow = function () {
    this.year++;
    this.girlfriend.push('hands');
    console.log(this.girlfriend);
    console.log(this.year);
};

Boy.prototype.year = 18;
Boy.prototype.girlfriend = [];

var me = new Boy();
me.grow(); //['hands']   19
me.grow(); //['hands', 'hands']    20

var you = new Boy();
you.grow(); //['hands', 'hands', 'hands'] 19
```

首先原型链查找这东西就不谈了，基础类型与引用类型的区别也不谈了。

谈谈上诉代码中对`this.属性`操作时发生了什么吧。

当grow函数执行时，它先进行查找对象本身属性，没有找到，然后查找原型链，查找到后`this.属性`的操作会将其复制到实例内部，然后就是基础类型与引用类型之间的区别了。

